# 算法
算法本质为解决问题的方法和步骤；  

## 如何看懂算法
(1)熟悉算法的流程控制（算法的执行顺序）  
(2)熟悉算法语句功能（语句的种类、作用及其内部语句执行顺序）  
(3)试数（看懂算法的关键）  

## 如何去写算法
首先我们需要写出详细的解题步骤（这非常重要），这甚至是解决问题的关键。  
之后我们需要坚持三个原则:  
(1)由简单到复杂：  
 验证一步走一步，多打印中间结果  
(2)由局部到整体：  
 复杂问题没思路，先细分  
(3)由粗糙到精细：  
 边界处理，语句合并，变量更名  

## 如何验证算法正确？  

两种方法:  
(1)肉眼观察，十分不可靠  
(2)产生足够多的随机样本，用确定的正确的官方的算法计算出结果，对比被验证算法的结果，十分可靠  


## 如何调试算法
真正优秀的算法并不是一次就写成功的，它需要经过很多次的调试，以解决各种各样的情况;  
调试步骤:  
(1)通读   
(2)输出中间值  
(3)剪功能  
这三步都是定位Bug,来修改Bug；  
## 衡量算法的标准
+ **时间复杂度（流程决定）**：算法需要执行语句的次数；用来描述算法的运行时间；  
+ **空间复杂度（流程决定）**：算法所需要的额外内存空间（与功能无关.你自己必须分配的）；  
+ **常数项时间（实现细节决定）**  

# 常数时间操作
如果一个操作的执行时间不以具体样本量为转移，每次执行的时间都固定，称这样的时间操作为常数时间操作；  
**常见的常数时间操作：**
算数运算：+、-、 * 、/、% 等；  
位运算：>>、>>>、<<、^、&、|、~等  
赋值、比较、自增、自减等  
数组寻址  

位运算快于+、-，+、-快于 * 、/  
执行时间不固定的操作都不是常数时间操作；   

如果一个算法的空间复杂度为O（1），则表明该算法无需开辟额外空间；  
如若解决同一问题的两个算法的时间复杂度相同，但又想知道哪个更好，这时我们需要比较常数项时间。我们无需理论常数项时间，只需取一个足够大的随机样本，运行两个算法，比较他们的执行时间即可；  
一般情况下，解决问题的算法流程，在时间复杂度上一定要尽可能低，先满足时间复杂度后，再使用最小的额外空间，称为该问题的最优解；  
一般情况下，最优解会忽略常数项时间这个因素，因为该因素只决定了实现层次上的考虑和优化，而与怎么解决该问题的思想无关。  

# 经典算法思想
|思想|说明|
|---|---|
|枚举算法|将问题所有答案一一列举出来，根据判断条件判断答案是否合适，一般用循环实现 如百钱买百鸡问题|  
|递推算法|分为顺推（从条件出发推结果，如斐波那契数列问题）和逆推（从结果出发推条件，如银行存款问题）|  
|递归算法|函数直接或间接调用自己 ，如汉诺塔问题|
|分治算法|分而治之，化繁为简，将大问题分解成若干相互独立子问题，这些子问题若不能简单求解，再将这些子问题分解成若干相互独立子问题直至子问题可以简单求解,子问题解的并集即为大问题的解；如归并排序|
|贪心算法|从问题某一个初始解出发，逐渐逼近给定的目标，以便尽快求出更好的解. 不能保证最优解,不能求最大最小解，只能求出满足某些约束条件的可行解. | 
|回溯算法|先选择某一种可能的情况进行试探，在试探过程中一旦发现此选择的假设是错误的，就退回一步重新选择并继续向前试探，如此反复进行直至证明解或无解。 |    
|动态规划|思想求解具有某种具有最优性质的问题; 将一类活动过程分解成若干个相互联系的阶段，在每一阶段都需要做出决策，从而使整个过程达到最优的效果;  | 
|迭代算法|不断用变量的旧值递推新值的过程。确定迭代变量(直接或间接由旧值推新值的变量)->建立迭代关系式（旧值和新值的关系或公式）->对迭代过程进行控制（确定其迭代什么时候结束)|
|模拟算法|对真实事物或过程的模拟;  |
|随机化法|随机选择，小概率错误，对同一问题求解两次可能会得到完全不同的效果，这两次求解问题所需的时间或得到的结果可能会有相当大的差别;|
